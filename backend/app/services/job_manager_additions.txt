    
    def _init_database(self):
        '''Initialize SQLite database with schema for optimization results'''
        conn = sqlite3.connect(str(self.db_path))
        conn.execute('''
            CREATE TABLE IF NOT EXISTS optimization_results (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                job_id TEXT NOT NULL,
                result_index INTEGER NOT NULL,
                params_json TEXT NOT NULL,
                metrics_json TEXT NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                UNIQUE(job_id, result_index)
            )
        ''')
        conn.execute('CREATE INDEX IF NOT EXISTS idx_job_id ON optimization_results(job_id)')
        conn.execute('CREATE INDEX IF NOT EXISTS idx_job_created ON optimization_results(job_id, created_at DESC)')
        
        # Enable WAL mode for better concurrency
        conn.execute('PRAGMA journal_mode=WAL')
        conn.execute('PRAGMA cache_size=10000')
        conn.commit()
        conn.close()
        logger.info(f'SQLite database initialized at {self.db_path}')
    
    def save_result(self, job_id: str, result: Dict, index: int):
        '''Save a single optimization result to SQLite database'''
        try:
            conn = sqlite3.connect(str(self.db_path))
            conn.execute('''
                INSERT OR REPLACE INTO optimization_results 
                (job_id, result_index, params_json, metrics_json)
                VALUES (?, ?, ?, ?)
            ''', (
                job_id,
                index,
                json.dumps(result.get('params', {})),
                json.dumps(result.get('metrics', {}))
            ))
            conn.commit()
            conn.close()
        except Exception as e:
            logger.error(f'Failed to save result {index} for job {job_id}: {e}')
    
    def get_results(self, job_id: str, page: int = 1, limit: int = 50) -> Dict:
        '''Get paginated optimization results from SQLite database'''
        offset = (page - 1) * limit
        
        try:
            conn = sqlite3.connect(str(self.db_path))
            cursor = conn.execute('''
                SELECT params_json, metrics_json 
                FROM optimization_results
                WHERE job_id = ?
                ORDER BY result_index
                LIMIT ? OFFSET ?
            ''', (job_id, limit, offset))
            
            results = []
            for row in cursor:
                results.append({
                    'params': json.loads(row[0]),
                    'metrics': json.loads(row[1])
                })
            
            # Get total count
            total = conn.execute(
                'SELECT COUNT(*) FROM optimization_results WHERE job_id = ?',
                (job_id,)
            ).fetchone()[0]
            
            conn.close()
            
            return {
                'results': results,
                'pagination': {
                    'page': page,
                    'limit': limit,
                    'total': total,
                    'pages': (total + limit - 1) // limit if total > 0 else 0
                }
            }
        except Exception as e:
            logger.error(f'Failed to get results for job {job_id}: {e}')
            # Fallback to reading from old JSON format
            return self._get_results_from_json(job_id, page, limit)
    
    def _get_results_from_json(self, job_id: str, page: int, limit: int) -> Dict:
        '''Fallback: Read results from old JSON format for backward compatibility'''
        state = self.load_state(job_id)
        if state and 'results' in state:
            all_results = state['results']
            start = (page - 1) * limit
            end = start + limit
            total = len(all_results)
            
            return {
                'results': all_results[start:end],
                'pagination': {
                    'page': page,
                    'limit': limit,
                    'total': total,
                    'pages': (total + limit - 1) // limit if total > 0 else 0
                }
            }
        
        return {
            'results': [],
            'pagination': {'page': page, 'limit': limit, 'total': 0, 'pages': 0}
        }
